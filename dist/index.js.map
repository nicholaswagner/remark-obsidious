{
  "version": 3,
  "sources": ["../src/ObsidiousVault.ts", "../src/ObsidiousUtils.ts", "../node_modules/unist-util-is/lib/index.js", "../node_modules/unist-util-visit-parents/lib/color.js", "../node_modules/unist-util-visit-parents/lib/index.js", "../node_modules/unist-util-visit/lib/index.js", "../src/createVisitObsidianEmbeds.ts", "../src/createVisitObsidianCallouts.ts", "../src/createVisitObsidianHilights.ts", "../src/RemarkObsidious.ts"],
  "sourcesContent": ["\n// These are pulled from https://help.obsidian.md/file-formats\nexport const ObsidiousVaultImageFiletypes = ['avif', 'bmp', 'gif', 'jpeg', 'jpg', 'png', 'svg', 'webp'];\n\n\nexport type ObsidiousVaultItem = {\n    extension?: string; // Always present for files (e.g., 'jpg', 'pdf' etc)\n    filepath: string;\n    fileType: string; // it will be 'folder' | 'file'; (i'm not gonna pull in schema validation just for this one line)\n    id: string;\n    label: string;\n    mtimeMs?: number; // last modified time in milliseconds\n};\n\nexport type ObsidiousFileTreeNode = {\n    children?: ObsidiousFileTreeNode[];\n    id: string;\n    label: string;\n}\n\nexport type ObsidiousVaultData = {\n    files: Record<string, ObsidiousVaultItem>;\n    fileTree: ObsidiousFileTreeNode[];\n    idsByExtension: Record<string, string[]>;\n    idsByLabelSlug: Record<string, string>;\n    idsByWebPath: Record<string, string>;\n    imageIds: string[];\n    stats: Record<string, any>;\n}\n\nexport type ObsidiousVaultInterface = {\n    initialize: (data: ObsidiousVaultData) => ObsidiousVaultInterface;\n    getAllFiles: () => ObsidiousVaultItem[];\n    getAllImageFiles: () => ObsidiousVaultItem[];\n    getFileForId: (id: string) => ObsidiousVaultItem | null;\n    getFileForLabelSlug: (labelSlug: string) => ObsidiousVaultItem | null;\n    getFileForWebPathSlug: (webPath: string) => ObsidiousVaultItem | null;\n    getFilesByExtension: (extension: string) => ObsidiousVaultItem[];\n    getFileTree: () => ObsidiousFileTreeNode[];\n}\n\nlet vaultData: ObsidiousVaultData | null = null;\n\nconst initialize = (data: ObsidiousVaultData): ObsidiousVaultInterface => {\n    if (vaultData) return ObsidiousVault;\n    vaultData = data;\n    return ObsidiousVault;\n};\n\nconst getFileForId = (id: string) => vaultData ? vaultData.files[id] || null : null;\nconst getFileForWebPathSlug = (webPath: string) => vaultData ? getFileForId(vaultData.idsByWebPath[webPath]) : null;\nconst getFileForLabelSlug = (labelSlug: string) => vaultData ? getFileForId(vaultData.idsByLabelSlug[labelSlug]) : null;\nconst getAllFiles = () => vaultData ? Object.values(vaultData.files) : [];\nconst getAllImageFiles = () => vaultData ? vaultData.imageIds.map(getFileForId).filter(item => item !== null) : [];\nconst getFileTree = () => vaultData ? vaultData.fileTree : [];\nconst getFilesByExtension = (extension: string): ObsidiousVaultItem[] => {\n    const ids = vaultData ? (vaultData.idsByExtension[extension] || []) : [];\n    return ids.map(getFileForId).filter(item => item !== null);\n}\n\nconst ObsidiousVault: ObsidiousVaultInterface = {\n    initialize,\n    getAllFiles,\n    getAllImageFiles,\n    getFileForId,\n    getFileForLabelSlug,\n    getFileForWebPathSlug,\n    getFilesByExtension,\n    getFileTree,\n    ...(vaultData || {}),\n};\n\nexport { ObsidiousVault };", "/**\n * Slugify a string by converting it to lowercase, removing diacritics, and replacing non-alphanumeric characters with underscores.\n * This implementation retains the \"/\" character so that I can create a slugged_folder looking structure that is similar to the original file structure.\n */\nexport const slugify = (str: string) =>\n    str\n        .toLowerCase()\n        .normalize(\"NFD\") // Convert accented chars to base form\n        .replace(/[\\u0300-\\u036f]/g, \"\") // Remove diacritics\n        .replace(/[^a-z0-9\\/]+/g, \"-\") // Replace non-alphanumeric (except `/`) with `-`\n        .replace(/_+/g, \"_\") // Collapse multiple underscores into one\n        .replace(/^_+|_+$/g, \"\"); // Trim leading/trailing `_`\n\n\nexport const slugifyFilepath = (filepath: string, extension?: string) =>\n    extension === 'md' ? slugify(filepath.replace(/\\.md$/, '')) : slugify(filepath);\n\n\n\n/**\n * MIT License\n * Copyright (c) Emotion team and other contributors\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n * Murmur2 hash implementation copied from: \n * https://github.com/emotion-js/emotion/blob/cce67ec6b2fc94261028b4f4778aae8c3d6c5fd6/packages/hash/src/index.ts#L5\n * \n */\n\n/* eslint-disable */\n// @ts-nocheck\n\nexport function hash(str: string): string {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n\n    // const m = 0x5bd1e995;\n    // const r = 24;\n\n    // Initialize the hash\n    var h = 0\n\n    // Mix 4 bytes at a time into the hash\n    var k,\n        i = 0,\n        len = str.length\n    for (; len >= 4; ++i, len -= 4) {\n        k =\n            (str.charCodeAt(i) & 0xff) |\n            ((str.charCodeAt(++i) & 0xff) << 8) |\n            ((str.charCodeAt(++i) & 0xff) << 16) |\n            ((str.charCodeAt(++i) & 0xff) << 24)\n\n        k =\n            /* Math.imul(k, m): */\n            (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0xe995) << 16)\n        k ^= /* k >>> r: */ k >>> 24\n\n        h =\n            /* Math.imul(k, m): */\n            ((k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0xe995) << 16)) ^\n            /* Math.imul(h, m): */\n            ((h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16))\n    }\n    // Handle the last few bytes of the input array\n    switch (len) {\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff\n            h =\n                /* Math.imul(h, m): */\n                (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16)\n    }\n    // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13\n    h =\n        /* Math.imul(h, m): */\n        (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0xe995) << 16)\n\n    return ((h ^ (h >>> 15)) >>> 0).toString(36)\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node\u2019s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node\u2019s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node\u2019s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node\u2019s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node\u2019s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node\u2019s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can\u2019t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you\u2019re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can\u2019t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n", "/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn\u2019t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > \uD83D\uDC49 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn\u2019t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn\u2019t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node\u2019s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn\u2019t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn\u2019t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it\u2019s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > \uD83D\uDC49 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn\u2019t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn\u2019t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n", "import { Visitor } from 'unist-util-visit';\nimport { Literal, PhrasingContent } from 'mdast';\nimport { RemarkObsidiousOptions } from './RemarkObsidious';\nimport { slugifyFilepath } from './ObsidiousUtils';\n\nconst obsidianEmbed = /!?\\[\\[[^\\]]+\\]\\]/g; // Matches all the ![[...]] in the markdown\nconst obsidianEmbedParams = /!?\\[\\[([^\\|\\]]+)(?:\\s*\\|\\s*([^\\|\\]]+))?\\]\\]/; // Captures the link and optional alias from inside the ![[...]]\n\n\n/**\n * Creates a visitor function that processes Obsidian links and embeds in markdown nodes.\n * When links are encountered, \n */\nconst createVisitObsidianEmbeds = ({ basePath, classNames, filePathPrefix, getVaultItemByLabelSlug, slugify }: RemarkObsidiousOptions): Visitor<Literal> => {\n    const { linkClassName, imageClassName, errorClassName, mdClassName } = classNames;\n    return (node, index, parent) => {\n        if (!node.value || typeof node.value !== 'string' || !parent || index === undefined) return;\n\n        if (!node.value?.match(obsidianEmbed)?.length) return;\n\n        const matches = [...node.value.matchAll(obsidianEmbed)];\n        const results: PhrasingContent[] = [];\n        let bufferIndex = 0;\n\n        for (const match of matches) {\n            if (bufferIndex !== match.index) {\n                results.push({ type: 'text', value: node.value.slice(bufferIndex, match.index) });\n            }\n            const params = match[0].match(obsidianEmbedParams);\n            if (!params) {\n                results.push({ type: 'text', value: match[0] });\n                bufferIndex = match.index + match[0].length;\n                continue;\n            }\n            const urlParamsIndex = params[1].indexOf('#');\n            const urlParams = urlParamsIndex !== -1 ? params[1].slice(urlParamsIndex + 1).trim() : '';\n            const isCarotParams = urlParams.startsWith('^');\n            const vaultItem = getVaultItemByLabelSlug(urlParamsIndex !== -1 ? slugify(params[1].slice(0, urlParamsIndex).trim()) : slugify(params[1].trim()));\n            const title = isCarotParams ? `${vaultItem?.label} > ${urlParams.slice(1)}` : params[1];\n\n            const fileUrl = `${filePathPrefix}${vaultItem?.filepath}`.replace(/\\/\\//g, \"/\");\n\n            if (!vaultItem) {\n                console.error(vaultItem);\n                results.push({\n                    type: 'text',\n                    value: `\"${params[1]}\" could not be found`,\n                    data: { hName: 'span', hProperties: { className: errorClassName } },\n                });\n            } else {\n                if (params[0].startsWith('!')) {\n\n                    if (vaultItem.extension === 'md') {\n                        /** if embedding a markdown file, change the parent element from <p> to <div> */\n                        parent.data = {\n                            ...parent.data,\n                            hName: 'div',\n                            hProperties: {\n                                className: mdClassName,\n                                options: params[2] ?? undefined,\n                                'data-file-id': vaultItem.id,\n                                'data-hash-params': slugify(urlParams),\n                            }\n                        }\n                    }\n                    else {\n                        results.push({\n                            type: 'image',\n                            url: fileUrl,\n                            alt: title,\n                            data: {\n                                hProperties: {\n                                    className: imageClassName,\n                                    options: params[2] ?? undefined,\n                                    src: fileUrl,\n                                    'data-ext': vaultItem.extension,\n                                    'data-label': vaultItem.label,\n                                },\n                            },\n                        });\n                    }\n\n                } else {\n                    const hash = urlParams ? `#${slugify(urlParams)}` : '';\n                    results.push({\n                        type: 'link',\n                        url: fileUrl + hash,\n                        title: params[2] ?? title,\n                        data: {\n                            hProperties: {\n                                className: linkClassName,\n                                options: params[2] ?? undefined,\n                                src: fileUrl,\n                                'data-ext': vaultItem.extension,\n                                'data-hash-params': slugify(urlParams),\n                                'data-label': vaultItem.label,\n                            },\n                        },\n                        children: [{ type: 'text', value: params[2] ?? title }],\n                    });\n                }\n            }\n            bufferIndex = match.index + match[0].length;\n        }\n        // Add any remaining text after the last match\n        if (bufferIndex < node.value.length) {\n            results.push({ type: 'text', value: node.value.slice(bufferIndex) });\n        }\n\n        if (typeof index === 'number' && parent.children) {\n            parent.children.splice(index, 1, ...results);\n        } else {\n            parent.children = results;\n        }\n    }\n}\n\nexport default createVisitObsidianEmbeds;", "import { Visitor } from 'unist-util-visit';\nimport type { Blockquote, Paragraph, Text } from 'mdast';\nimport type { RemarkObsidiousOptions } from './RemarkObsidious'\n\ntype ExtendedBlockquote = Blockquote & {\n    data?: Blockquote[\"data\"] & {\n        hProperties?: Record<string, any>;\n    };\n};\n\ntype ExtendedParagraph = Paragraph & {\n    data?: {\n        hProperties?: Record<string, any>;\n    }\n}\n\nconst calloutRegex = /^\\[\\!\\s*([\\w-]+)\\s*\\]([-+]?)/;\nconst createVisitObsidianCallouts = ({ classNames }: RemarkObsidiousOptions): Visitor<ExtendedBlockquote> => {\n    const { calloutClassName, calloutIsFoldableClassName, calloutTitleClassName } = classNames;\n    return (blockquoteNode) => {\n        if (!Array.isArray(blockquoteNode.children) || blockquoteNode.children.length === 0) return;\n\n        const firstParagraph = blockquoteNode.children.find((child) => child.type === 'paragraph') as ExtendedParagraph | undefined;\n        if (!firstParagraph || firstParagraph.children.length === 0) return;\n\n        const firstTextNode = firstParagraph.children.find((child) => child.type === 'text') as Text | undefined;\n        if (!firstTextNode || typeof firstTextNode.value !== 'string' || firstTextNode.value.trim() === '') return;\n\n        const match = calloutRegex.exec(firstTextNode.value);\n        if (!match) return;\n\n        const calloutType = match[1].toLowerCase(); // e.g. 'note', 'warning', 'info', etc.\n        const foldableModifier = match[2] || ''; // - or + or empty\n        const isFoldable = foldableModifier !== ''; // true if - or +\n        const initialFolded = foldableModifier === '-'; // true if -\n\n\n        firstTextNode.value = firstTextNode.value.replace(calloutRegex, '').trim(); // strip out the [! callout] part\n\n        const titleText = firstTextNode.value || calloutType;\n\n        blockquoteNode.data ??= {};\n        blockquoteNode.data.hProperties = {\n            ...blockquoteNode.data.hProperties,\n            'data-callout': calloutType,\n            'data-initial-folded': String(initialFolded),\n            'data-title': titleText,\n            className: [calloutClassName, isFoldable ? calloutIsFoldableClassName : '']\n        };\n\n        firstParagraph.data ??= {};\n        if (!firstParagraph.data.hProperties) firstParagraph.data.hProperties = {};\n        firstParagraph.data.hProperties = {\n            ...firstParagraph.data.hProperties,\n            className: [calloutTitleClassName],\n            'data-callout': calloutType,\n            'data-title': titleText\n        };\n    };\n};\n\n\nexport default createVisitObsidianCallouts;", "import { Visitor } from 'unist-util-visit';\nimport { PhrasingContent } from 'mdast';\nimport { RemarkObsidiousOptions } from './RemarkObsidious'\nimport type { Text } from 'mdast';\n\n\nconst hilight = /==([^=]+)==/gm;\n\nconst createVisitObsidianHilights = ({ classNames }: RemarkObsidiousOptions): Visitor<Text> => {\n    const { hilightClassName } = classNames;\n\n    return (node, index, parent) => {\n        if (!node.value || typeof node.value !== 'string' || !parent || index === undefined) return;\n\n        const matches = [...node.value.matchAll(hilight)];\n\n        if (matches.length === 0) return;\n\n        const results: PhrasingContent[] = [];\n\n        let bufferIndex = 0;\n\n        for (const match of matches) {\n            if (bufferIndex !== match.index) {\n                results.push({ type: 'text', value: node.value.slice(bufferIndex, match.index) });\n            }\n\n            results.push({\n                type: 'text',\n                value: match[1],\n                data: { hName: 'mark', hProperties: { className: hilightClassName } },\n            });\n\n            bufferIndex = match.index + match[0].length;\n        }\n\n        if (bufferIndex < node.value.length)\n            results.push({ type: 'text', value: node.value.slice(bufferIndex) });\n\n        if (parent.children) {\n            parent.children.splice(index, 1, ...results);\n        }\n\n    }\n}\n\nexport default createVisitObsidianHilights;", "import { Transformer } from 'unified';\nimport { visit } from 'unist-util-visit';\nimport { Plugin } from \"unified\";\nimport { Root } from 'mdast';\n\nimport { slugify } from './ObsidiousUtils';\nimport createVisitObsidianEmbeds from './createVisitObsidianEmbeds';\nimport createVisitObsidianCallouts from './createVisitObsidianCallouts';\nimport createVisitObsidianHilights from './createVisitObsidianHilights';\n\nimport { ObsidiousVault, type ObsidiousVaultItem } from './ObsidiousVault'\n\nexport type RemarkObsidiousOptions = {\n    basePath: string;\n    classNames: {\n        calloutClassName: string;\n        calloutIsFoldableClassName: string;\n        calloutTitleClassName: string;\n        errorClassName: string;\n        hilightClassName: string;\n        imageClassName: string;\n        linkClassName: string;\n        mdClassName: string;\n    };\n    filePathPrefix: string;\n    slugify: typeof slugify;\n    getVaultItemByLabelSlug: (labelSlug: string) => ObsidiousVaultItem | null;\n};\n\n\nexport type ObsidiousOptions = Partial<Omit<RemarkObsidiousOptions, 'classNames'> & {\n    classNames?: Partial<RemarkObsidiousOptions['classNames']>;\n}>;\n\nexport const DefaultRemarkObsidiousOptions: RemarkObsidiousOptions = {\n    basePath: '',\n    classNames: {\n        calloutClassName: 'callout',\n        calloutIsFoldableClassName: 'foldable',\n        calloutTitleClassName: 'callout-title',\n        errorClassName: 'obsidian-md-error',\n        hilightClassName: 'obsidian-hilight',\n        imageClassName: 'obsidian-img',\n        linkClassName: 'obsidian-link',\n        mdClassName: 'obsidian-md-embed ',\n    },\n    filePathPrefix: '',\n    slugify,\n    getVaultItemByLabelSlug: (labelSlug: string) => ObsidiousVault.getFileForLabelSlug(labelSlug),\n};\n\nconst RemarkObsidious: Plugin<[ObsidiousOptions?], Root> = (options: ObsidiousOptions = {}): Transformer<Root, Root> => {\n\n    const config: RemarkObsidiousOptions = {\n        ...DefaultRemarkObsidiousOptions,\n        ...options,\n        classNames: {\n            ...DefaultRemarkObsidiousOptions.classNames,\n            ...options?.classNames,\n        },\n    };\n    const visitObsidianEmbeds = createVisitObsidianEmbeds({ ...config });\n    const visitObsidianCallouts = createVisitObsidianCallouts({ ...config });\n    const visitObsidianHilights = createVisitObsidianHilights({ ...config });\n\n    return (tree) => {\n        visit(tree, 'blockquote', visitObsidianCallouts);\n        visit(tree, 'text', visitObsidianHilights);\n        visit(tree, 'text', visitObsidianEmbeds);\n    };\n}\n\nexport default RemarkObsidious;"],
  "mappings": "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",
  "names": ["index", "is", "visit", "slugify", "hash"]
}
