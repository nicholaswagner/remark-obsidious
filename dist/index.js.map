{
  "version": 3,
  "sources": ["../node_modules/unist-util-is/lib/index.js", "../node_modules/unist-util-visit-parents/lib/index.js", "../node_modules/unist-util-visit/lib/index.js", "../src/createVisitObsidianEmbeds.ts", "../src/createVisitObsidianCallouts.ts", "../src/createVisitObsidianHilights.ts", "../src/slugify.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node\u2019s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node\u2019s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node\u2019s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node\u2019s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node\u2019s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node\u2019s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can\u2019t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you\u2019re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can\u2019t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn\u2019t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > \uD83D\uDC49 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn\u2019t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn\u2019t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node\u2019s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn\u2019t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn\u2019t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when it\u2019s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > \uD83D\uDC49 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn\u2019t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn\u2019t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n", "import { Visitor } from 'unist-util-visit';\nimport { Literal, PhrasingContent } from 'mdast';\nimport { PluginOptions } from './types/ObsidiousOptions';\n\nconst obsidianEmbed = /!?\\[\\[[^\\]]+\\]\\]/g; // Matches all the ![[...]] in the markdown\nconst obsidianEmbedParams = /!?\\[\\[([^\\|\\]]+)(?:\\s*\\|\\s*([^\\|\\]]+))?\\]\\]/; // Captures the link and optional alias from inside the ![[...]]\n\n\n/**\n * Creates a visitor function that processes Obsidian links and embeds in markdown nodes.\n * When links are encountered, \n */\nconst createVisitObsidianEmbeds = ({ basePath, classNames, filePathPrefix, getFileMetaForLabel, slugify }: PluginOptions): Visitor<Literal> => {\n    const { linkClassName, imageClassName, errorClassName, embeddedMdClassName } = classNames;\n    return (node, index, parent) => {\n        if (!node.value || typeof node.value !== 'string' || !parent || index === undefined) return;\n\n        if (!node.value?.match(obsidianEmbed)?.length) return;\n\n        const matches = [...node.value.matchAll(obsidianEmbed)];\n        const results: PhrasingContent[] = [];\n        let bufferIndex = 0;\n\n        for (const match of matches) {\n            if (bufferIndex !== match.index) {\n                results.push({ type: 'text', value: node.value.slice(bufferIndex, match.index) });\n            }\n            const params = match[0].match(obsidianEmbedParams);\n            if (!params) {\n                results.push({ type: 'text', value: match[0] });\n                bufferIndex = match.index + match[0].length;\n                continue;\n            }\n            const urlParamsIndex = params[1].indexOf('#');\n            const urlParams = urlParamsIndex !== -1 ? params[1].slice(urlParamsIndex) : '';\n            const isCarotParams = urlParams.startsWith('^');\n            const file = getFileMetaForLabel(urlParamsIndex !== -1 ? slugify(params[1].slice(0, urlParamsIndex)) : slugify(params[1]));\n            const title = isCarotParams ? `${file?.label} > ${urlParams.slice(1)}` : params[1];\n\n            if (!file) {\n                console.error(file);\n                results.push({\n                    type: 'text',\n                    value: `\"${params[1]}\" could not be found`,\n                    data: { hName: 'span', hProperties: { className: errorClassName } },\n                });\n            } else {\n                if (params[0].startsWith('!')) {\n                    const src = file.filepath;\n\n                    if (file.extension === 'md') {\n                        /** if embedding a markdown file, change the parent element from <p> to <div> */\n                        parent.data = {\n                            ...parent.data,\n                            hName: 'div',\n                            hProperties: {\n                                className: embeddedMdClassName,\n                                options: params[2] ?? undefined,\n                                'data-file-id': file.id,\n                                'data-hash-params': slugify(urlParams),\n                            }\n                        }\n                    }\n                    else {\n                        results.push({\n                            type: 'image',\n                            url: src,\n                            alt: title,\n                            data: {\n                                hProperties: {\n                                    className: imageClassName,\n                                    options: params[2] ?? undefined,\n                                    src: filePathPrefix + src,\n                                    'data-ext': file.extension,\n                                    'data-weburl': file.webPath,\n                                    'data-hash-params': slugify(urlParams),\n                                    'data-label': file.label,\n                                },\n                            },\n                        });\n                    }\n\n                } else {\n                    results.push({\n                        type: 'link',\n                        url: basePath + file.webPath + urlParams,\n                        title,\n                        data: {\n                            hProperties: {\n                                className: linkClassName,\n                                options: params[2] ?? undefined,\n                                src: filePathPrefix + file.filepath,\n                                'data-ext': file.extension,\n                                'data-weburl': file.webPath,\n                                'data-hash-params': slugify(urlParams),\n                                'data-label': file.label,\n                            },\n                        },\n                        children: [{ type: 'text', value: title }],\n                    });\n                }\n            }\n            bufferIndex = match.index + match[0].length;\n        }\n        // Add any remaining text after the last match\n        if (bufferIndex < node.value.length) {\n            results.push({ type: 'text', value: node.value.slice(bufferIndex) });\n        }\n\n        if (typeof index === 'number' && parent.children) {\n            parent.children.splice(index, 1, ...results);\n        } else {\n            parent.children = results;\n        }\n    }\n}\n\nexport default createVisitObsidianEmbeds;", "import { Visitor } from 'unist-util-visit';\nimport { PluginOptions } from './types/ObsidiousOptions';\nimport type { Blockquote, Paragraph, Text } from 'mdast';\n\ntype ExtendedBlockquote = Blockquote & {\n    data?: Blockquote[\"data\"] & {\n        hProperties?: Record<string, any>;\n    };\n};\n\ntype ExtendedParagraph = Paragraph & {\n    data?: {\n        hProperties?: Record<string, any>;\n    }\n}\n\nconst calloutRegex = /^\\[\\!\\s*([\\w-]+)\\s*\\]([-+]?)/;\nconst createVisitObsidianCallouts = ({ classNames }: PluginOptions): Visitor<ExtendedBlockquote> => {\n    const { calloutClassName, calloutIsFoldableClassName, calloutTitleClassName } = classNames;\n    return (blockquoteNode) => {\n        if (!Array.isArray(blockquoteNode.children) || blockquoteNode.children.length === 0) return;\n\n        const firstParagraph = blockquoteNode.children.find((child) => child.type === 'paragraph') as ExtendedParagraph | undefined;\n        if (!firstParagraph || firstParagraph.children.length === 0) return;\n\n        const firstTextNode = firstParagraph.children.find((child) => child.type === 'text') as Text | undefined;\n        if (!firstTextNode || typeof firstTextNode.value !== 'string' || firstTextNode.value.trim() === '') return;\n\n        const match = calloutRegex.exec(firstTextNode.value);\n        if (!match) return;\n\n        const calloutType = match[1].toLowerCase(); // e.g. 'note', 'warning', 'info', etc.\n        const foldableModifier = match[2] || ''; // - or + or empty\n        const isFoldable = foldableModifier !== ''; // true if - or +\n        const initialFolded = foldableModifier === '-'; // true if -\n\n\n        firstTextNode.value = firstTextNode.value.replace(calloutRegex, '').trim(); // strip out the [! callout] part\n\n        const titleText = firstTextNode.value || calloutType;\n\n        blockquoteNode.data ??= {};\n        blockquoteNode.data.hProperties = {\n            ...blockquoteNode.data.hProperties,\n            'data-callout': calloutType,\n            'data-initial-folded': String(initialFolded),\n            'data-title': titleText,\n            className: [calloutClassName, isFoldable ? calloutIsFoldableClassName : '']\n        };\n\n        firstParagraph.data ??= {};\n        if (!firstParagraph.data.hProperties) firstParagraph.data.hProperties = {};\n        firstParagraph.data.hProperties = {\n            ...firstParagraph.data.hProperties,\n            className: [calloutTitleClassName],\n            'data-callout': calloutType,\n            'data-title': titleText\n        };\n    };\n};\n\n\nexport default createVisitObsidianCallouts;", "import { Visitor } from 'unist-util-visit';\nimport { PhrasingContent } from 'mdast';\nimport { PluginOptions } from './types/ObsidiousOptions';\nimport type { Text } from 'mdast';\n\n\nconst hilight = /==([^=]+)==/gm;\n\nconst createVisitObsidianHilights = ({ classNames }: PluginOptions): Visitor<Text> => {\n    const { hilightClassName } = classNames;\n\n    return (node, index, parent) => {\n        if (!node.value || typeof node.value !== 'string' || !parent || index === undefined) return;\n\n        const matches = [...node.value.matchAll(hilight)];\n\n        if (matches.length === 0) return;\n\n        const results: PhrasingContent[] = [];\n\n        let bufferIndex = 0;\n\n        for (const match of matches) {\n            if (bufferIndex !== match.index) {\n                results.push({ type: 'text', value: node.value.slice(bufferIndex, match.index) });\n            }\n\n            results.push({\n                type: 'text',\n                value: match[1],\n                data: { hName: 'span', hProperties: { className: hilightClassName } },\n            });\n\n            bufferIndex = match.index + match[0].length;\n        }\n\n        if (bufferIndex < node.value.length)\n            results.push({ type: 'text', value: node.value.slice(bufferIndex) });\n\n        if (parent.children) {\n            parent.children.splice(index, 1, ...results);\n        }\n\n    }\n}\n\nexport default createVisitObsidianHilights;", "/**\n * Slugify a string by converting it to lowercase, removing diacritics, and replacing non-alphanumeric characters with underscores.\n * This implementation chooses to retain the \"/\" character so that I can create a slugged folder structure that the user will recognize.\n */\nexport const slugify = (str: string) =>\n    str\n        .toLowerCase()\n        .normalize(\"NFD\") // Convert accented chars to base form\n        .replace(/[\\u0300-\\u036f]/g, \"\") // Remove diacritics\n        .replace(/[^a-z0-9\\/]+/g, \"_\") // Replace non-alphanumeric (except `/`) with `_`\n        .replace(/_+/g, \"_\") // Collapse multiple underscores into one\n        .replace(/^_+|_+$/g, \"\"); // Trim leading/trailing `_`", "import { Transformer } from 'unified';\nimport { visit } from 'unist-util-visit';\nimport { Plugin } from \"unified\";\nimport { Root } from 'mdast';\n\n\nimport createVisitObsidianEmbeds from './createVisitObsidianEmbeds';\nimport createVisitObsidianCallouts from './createVisitObsidianCallouts';\nimport createVisitObsidianHilights from './createVisitObsidianHilights';\nimport { slugify } from './slugify';\n\nimport type { FileMeta } from './types/VaultItem';\nimport type { PluginOptions } from './types/PluginOptions';\n\nexport { slugify } from './slugify';\nexport type ObsidiousOptions = Partial<PluginOptions>;\n\nconst defaultConfig: PluginOptions = {\n    basePath: '/',\n    classNames: {\n        calloutClassName: 'callout',\n        calloutIsFoldableClassName: 'foldable',\n        calloutTitleClassName: 'callout-title',\n        errorClassName: 'obsidian-md-error',\n        hilightClassName: 'obsidian-hilight',\n        imageClassName: 'obsidian-img',\n        linkClassName: 'obsidian-link',\n        embeddedMdClassName: 'obsidian-md-embed ',\n    },\n    filePathPrefix: '/vault/',\n    slugify,\n    getFileMetaForLabel: (_label: string): FileMeta | null => null,\n};\n\n\nconst remarkObsidious: Plugin<[ObsidiousOptions], Root> = (options?: ObsidiousOptions): Transformer<Root, Root> => {\n    const config = { ...defaultConfig, ...options };\n\n    const visitObsidianEmbeds = createVisitObsidianEmbeds({ ...config });\n    const visitObsidianCallouts = createVisitObsidianCallouts({ ...config });\n    const visitObsidianHilights = createVisitObsidianHilights({ ...config });\n\n    return (tree) => {\n        visit(tree, 'blockquote', visitObsidianCallouts);\n        visit(tree, 'text', visitObsidianHilights);\n        visit(tree, 'text', visitObsidianEmbeds);\n    };\n}\n\n\nexport default remarkObsidious;"],
  "mappings": "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",
  "names": ["convert", "test", "ok", "castFactory", "anyFactory", "propsFactory", "typeFactory", "tests", "checks", "index", "any", "parameters", "check", "checkAsRecord", "all", "node", "nodeAsRecord", "key", "type", "testFunction", "value", "parent", "looksLikeANode", "empty", "CONTINUE", "EXIT", "SKIP", "visitParents", "tree", "test", "visitor", "reverse", "check", "is", "convert", "step", "factory", "node", "index", "parents", "value", "name", "visit", "result", "subresult", "offset", "grandparents", "toResult", "nodeAsParent", "child", "visit", "tree", "testOrVisitor", "visitorOrReverse", "maybeReverse", "reverse", "test", "visitor", "visitParents", "overload", "node", "parents", "parent", "index", "obsidianEmbed", "obsidianEmbedParams", "createVisitObsidianEmbeds", "basePath", "classNames", "filePathPrefix", "getFileMetaForLabel", "slugify", "linkClassName", "imageClassName", "errorClassName", "embeddedMdClassName", "node", "index", "parent", "matches", "results", "bufferIndex", "match", "params", "urlParamsIndex", "urlParams", "isCarotParams", "file", "title", "src", "createVisitObsidianEmbeds_default", "calloutRegex", "createVisitObsidianCallouts", "classNames", "calloutClassName", "calloutIsFoldableClassName", "calloutTitleClassName", "blockquoteNode", "firstParagraph", "child", "firstTextNode", "match", "calloutType", "foldableModifier", "isFoldable", "initialFolded", "titleText", "createVisitObsidianCallouts_default", "hilight", "createVisitObsidianHilights", "classNames", "hilightClassName", "node", "index", "parent", "matches", "results", "bufferIndex", "match", "createVisitObsidianHilights_default", "slugify", "str", "defaultConfig", "slugify", "_label", "remarkObsidious", "options", "config", "visitObsidianEmbeds", "createVisitObsidianEmbeds_default", "visitObsidianCallouts", "createVisitObsidianCallouts_default", "visitObsidianHilights", "createVisitObsidianHilights_default", "tree", "visit", "index_default"]
}
